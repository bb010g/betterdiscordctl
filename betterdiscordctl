#!/bin/bash

shopt -s dotglob extglob nullglob

# Constants
VERSION=1.2.0
GITHUB_URL='https://raw.githubusercontent.com/bb010g/betterdiscordctl/master/betterdiscordctl'
DISABLE_UPGRADE=

# Options
cmd=status
verbosity=0
scan=/opt
flavors=('' Canary PTB)
discord=
modules=
bd_repo='https://github.com/rauenzi/BetterDiscordApp'
bd_repo_branch=stable16
bd=
copy_bd=
global_asar=
snap=
flatpak=

# Variables
flavor=
core=
xdg_config="${XDG_CONFIG_DIR:-$HOME/.config}"
data="${XDG_DATA_HOME:-$HOME/.local/share}/betterdiscordctl"

show_help() {
  printf 'Usage: %s [COMMAND] [OPTION...]\n\n' "${0##*/}"
  cat << EOF
Options:
  -V, --version                  Display version info and exit
  -h, --help                     Display this help message and exit
  -v, --verbose                  Increase verbosity
  -s, --scan=DIRECTORY           Directory to scan for Discord installation
                                 (default '/opt')
  -f, --flavors=FLAVORS          Comma-separated list of Discord flavors
                                 (default ',Canary,PTB')
  -d, --discord=DIRECTORY        Use specified Discord directory
                                 (requires --modules)
  -m, --modules=DIRECTORY        Use specified Discord modules directory
  -r, --bd-repo=REPOSITORY       Use specified Git repo for BetterDiscord
      --bd-repo-branch=BRANCH    Use specified Git branch for BetterDiscord
                                 (default 'stable16')
  -b, --betterdiscord=DIRECTORY  Use specified BetterDiscord directory
  -c, --copy-bd                  Copy BD directory instead of symlinking
      --global-asar              Use the asar in PATH instead of local
      --snap                     Use the Snap version of Discord
      --flatpak                  Use the Flatpak version of Discord

Commands:
  status (default)               Show the current Discord patch state.
  install                        Install BetterDiscord.
  update                         Update BetterDiscord.
  uninstall                      Uninstall BetterDiscord.
  upgrade                        Update betterdiscordctl.
EOF
}

verbose() {
  if (( verbosity >= $1 )); then
    shift
    printf '%s\n' "$1"
  fi
}

die() {
  if [ -z "$2" ]; then printf '%s\n' "$1" >&2
  else printf '%s\n%s\n' "$1" "$2" >&2; fi
  exit 1
}

die_with_help() {
  die "$1" 'Use "--help" for more information.'
}

die_non_empty() {
  die_with_help "ERROR: \"$1\" requires a non-empty option argument."
}


while :; do
  case $1 in
    status|install|update|uninstall|upgrade)
      cmd=$1
      ;;
    -V|--version)
      printf 'betterdiscordctl %s\n' "$VERSION" >&2
      exit
      ;;
    -h|-\?|--help)
      show_help; exit
      ;;
    -v|--verbose)
      ((++verbosity))
      ;;
    -s|--scan)
      if [ "$2" ]; then scan=$2; shift
      else die_non_empty '--scan'; fi
      ;;
    --scan=?*)
      scan=${1#*=}
      ;;
    --scan=)
      die_non_empty '--scan'
      ;;
    -f|--flavors)
      if [ "$2" ]; then IFS=',' read -ra flavors <<< "$2"; shift
      else die_non_empty '--flavors'; fi
      ;;
    --flavors=?*)
      IFS=',' read -ra flavors <<< "${1#*=}"
      ;;
    --flavors=)
      die_non_empty '--flavors'
      ;;
    -d|--discord)
      if [ "$2" ]; then discord=$2; shift
      else die_non_empty '--discord'; fi
      ;;
    --discord=?*)
      discord=${1#*=}
      ;;
    --discord=)
      die_non_empty '--discord'
      ;;
    -m|--modules)
      if [ "$2" ]; then modules=$2; shift
      else die_non_empty '--modules'; fi
      ;;
    --modules=?*)
      modules=${1#*=}
      ;;
    --modules=)
      die_non_empty '--modules'
      ;;
    --bd-repo-branch)
      if [ "$2" ]; then bd_repo_branch=$2; shift
      else die_non_empty '--bd-repo-branch'; fi
      ;;
    --bd-repo-branch=?*)
      bd_repo_branch=${1#*=}
      ;;
    --bd-repo-branch=)
      die_non_empty '--bd-repo-branch'
      ;;
    -r|--bd-repo)
      if [ "$2" ]; then bd_repo=$2; shift
      else die_non_empty '--bd-repo'; fi
      ;;
    --bd-repo=?*)
      bd_repo=${1#*=}
      ;;
    --bd-repo=)
      die_non_empty '--bd-repo'
      ;;
    -b|--betterdiscord)
      if [ "$2" ]; then bd=$2; shift
      else die_non_empty '--betterdiscord'; fi
      ;;
    --betterdiscord=?*)
      bd=${1#*=}
      ;;
    --betterdiscord=)
      die_non_empty '--betterdiscord'
      ;;
    -c|--copy-bd)
      copy_bd=yes
      ;;
    --global-asar)
      global_asar=yes
      ;;
    --snap)
      snap=yes
      copy_bd=yes
      ;;
    --flatpak)
      flatpak=yes
      copy_bd=yes
      ;;
    --)
      shift
      break
      ;;
    -?*)
      printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
      ;;
    *)
      break
  esac
  shift
done

mkdir -p "$data"
[ ! -f "$data/bd_map" ] && touch "$data/bd_map"

if [ "$snap" ]; then
  discord=$(grep Icon /var/lib/snapd/desktop/applications/discord_discord.desktop | sed 's/Icon=//g; s/\/discord.png//g')
  xdg_config="$(snap run --shell discord <<< 'echo "${XDG_CONFIG_HOME:-$SNAP_USER_DATA/.config}"')"
  discord_config="$xdg_config/discord"
  modules=("$discord_config/"+([0-9]).+([0-9]).+([0-9])'/modules')
  if ((! ${#modules[@]})); then
    die 'ERROR: Discord modules directory not found.'
  fi
  modules="${modules[0]}"
fi

if [ "$flatpak" ]; then
  flatpak_location="$(readlink -f "$(flatpak info com.discordapp.Discord | grep 'Location:' | sed 's/Location: //g')")"
  discord="$flatpak_location/files/extra"
  verbose 2 "VV: Checking $discord" >&2
  if [ -d "$discord" ]; then
    verbose 1 "V: Using Discord at $discord" >&2
    discord_config="$HOME/.var/app/com.discordapp.Discord/config/discord"
    if [ ! -d "$discord_config" ]; then
      printf 'WARN: Config directory not found for Discord (%s, %s).\n' "$discord" "$discord_config" >&2
    fi
    modules=("$discord_config/"+([0-9]).+([0-9]).+([0-9])'/modules')
    if ((! ${#modules[@]})); then
      die 'ERROR: Discord modules directory not found.'
    fi
    modules="${modules[0]}"
  else
    die 'ERROR: Discord installation not found.'
  fi
fi

if [ "$cmd" != upgrade ]; then
  if [ -z "$discord" ]; then
    while true; do
      for flavor in "${flavors[@]// }"; do
        verbose 2 "VV: Trying flavor '$flavor'" >&2
        for discord in "$scan/discord${flavor,,}" "$scan/discord-${flavor,,}" \
                       "$scan/Discord$flavor" "$scan/Discord-$flavor"; do
          verbose 2 "VV: Checking $discord" >&2
          if [ -d "$discord" ] ; then
            verbose 2 "VV: Detected $discord" >&2
            discord_config="$xdg_config/discord${flavor,,}"
            if [ ! -d "$discord_config" ]; then
              printf 'WARN: Config directory not found for %s (%s, %s).\n' "$flavor" "$discord" "$discord_config" >&2
              continue 2
            fi
            verbose 1 "V: Using Discord at $discord" >&2
            if [ -z "$modules" ]; then
              modules=("$discord_config/"+([0-9]).+([0-9]).+([0-9])'/modules')
              if ((! ${#modules[@]})); then
                die 'ERROR: Discord modules directory not found.'
              fi
              modules="${modules[0]}"
            else
              # --modules
              if [ ! -d "$modules" ]; then
                die 'ERROR: Discord modules directory not found.'
              fi
            fi
            break 3
          fi
        done
      done
      die 'ERROR: Discord installation not found.'
      break
    done
  else
    flavor="$flavors"
    # --discord and --modules
    if [ -z "$modules" ]; then
      die_with_help 'ERROR: "--discord" requires "--modules" to also be set.'
    fi
    if [ ! -d "$discord" ]; then
      die 'ERROR: Discord installation not found.'
    fi
    if [ ! -d "$modules" ]; then
      die 'ERROR: Discord modules directory not found.'
    fi
  fi
  core="$modules/discord_desktop_core"
  if [ ! -d "$core" ]; then
    die "ERROR: Directory 'discord_desktop_core' not found in '$(readlink -f "$modules")'"
  fi
fi

# Commands

bdc_status() {
  app_patched=no
  core_patched=no
  linked_dir=no
  linked_repo=no
  if [ -d "$discord/resources/app" ]; then
    app_patched=yes
  fi
  if [ -d "$core/core" ]; then
    core_patched=yes
    if [ -h "$core/core/node_modules/betterdiscord" ]; then
      linked_dir="$(readlink "$core/core/node_modules/betterdiscord")"
      if [ -d "$core/core/node_modules/betterdiscord" ]; then
        pushd "$core/core/node_modules/betterdiscord" >/dev/null
        linked_repo="$(git remote get-url origin 2>/dev/null || printf 'no\n')"
        popd >/dev/null
      else
        linked_dir="(broken link) $linked_dir"
      fi
    fi
  fi

  printf 'Discord: %s
Modules: %s
App patched: %s
Core patched: %s
Linked core directory: %s
Linked core repository: %s\n' \
    "$discord" "$modules" "$app_patched" "$core_patched" "$linked_dir" "$linked_repo"
}

bdc_install() {
  if [ -d "$core/core" ]; then
    die 'ERROR: Already installed.'
  fi

  bd_patch

  if [ ! "$bd" ]; then
    printf 'Cloning %s...\n' "$bd_repo" >&2
    bd="$data/bd/$(bd_map_add "$discord" "$bd_repo")"
    if [ ! -d "$bd" ]; then
      git clone "$bd_repo" -b "$bd_repo_branch" --single-branch "$bd"
    fi
  fi

  if [ "$copy_bd" ]; then
    verbose 1 'V: Copying core loader...' >&2
    cp -r "$bd" "$core/core/node_modules/betterdiscord"
  else
    verbose 1 'V: Linking core loader...' >&2
    ln -s "$bd" "$core/core/node_modules/betterdiscord"
  fi

  printf 'Installed. (Restart Discord if necessary.)\n' >&2
}

bdc_update() {
  if [ ! -d "$core/core" ]; then
    printf 'Not installed.\n' >&2
    exit 1
  fi

  if [ ! -d "$core/core/node_modules/betterdiscord" ]; then
    if [ -h "$core/core/node_modules/betterdiscord" ]; then
      die 'ERROR: Core BetterDiscord symbolic link is broken.'
    else
      die 'ERROR: Core BetterDiscord location is not a directory.'
    fi
  fi
  pushd "$core/core/node_modules/betterdiscord" >/dev/null
  if git rev-parse --is-inside-work-tree > /dev/null 2>/dev/null; then
    printf 'Updating Git repository...\n' >&2
    git fetch origin
    git reset --hard "origin/$bd_repo_branch"
  else
    printf 'No Git repository found.\n' >&2
  fi
  popd >/dev/null
}

bdc_uninstall() {
  if [ ! -e "$core/core" ]; then
    printf 'Not installed.\n' >&2
    exit 1
  fi

  if [ -z "$flavor" ]; then
    process_name='Discord'
  else
    if [ "${flavor,,}" == 'ptb' ]; then
      process_name='DiscordPTB'
    else
      process_name='DiscordCanary'
    fi
  fi

  printf 'Killing %s processes...\n' "$process_name" >&2
  pkill -ex -SIGKILL $(ps ax | awk "BEGIN{IGNORECASE=1}/discord(-){0,1}${flavor}/{print \$5}" | rev | \
                      cut -d '/' -f1 | rev | grep -iE "^discord(-){0,1}${flavor}$" | head -1) 2>/dev/null

  bd_unpatch

  # Remove managed BD repo if applicable
  bd_n=$(bd_map_get_dir "$discord" | bd_map_entry_n)
  bd_map_remove "$discord"
  if [ -z "$(bd_map_get_n $bd_n)" ]; then
    rm -rf "$data/bd/$bd_n"
  fi

  # Clean up legacy cruft
  if [ -d "$discord/resources/app" ]; then
    rm -r "$discord/resources/app"
  fi

  printf 'Uninstalled.\n' >&2
}

bdc_upgrade() {
  if [ "$DISABLE_UPGRADE" ]; then
    die 'ERROR: Upgrading has been disabled.' 'If you installed this from a package, your maintainer should keep betterdiscordctl up to date.'
    return
  fi
  github_version="$(curl -sN "$GITHUB_URL" | grep 'VERSION=' -m1 | cut -d '=' -f2)"
  if [ "${PIPESTATUS[0]}" -ne 0 ]; then
    die "ERROR: GitHub couldn't be reached to check the version."
  fi
  verbose 1 "V: GitHub version $github_version" >&2
  if semverGT "$github_version" "$VERSION"; then
    printf 'Downloading betterdiscordctl...\n' >&2
    if curl -Sso /usr/local/bin/betterdiscordctl "$GITHUB_URL"; then
      printf 'Successfully updated betterdiscordctl.\n' >&2
    else
      die 'ERROR: Failed to update betterdiscordctl.' 'You may want to rerun this with sudo.'
    fi
    if semverEQ "$github_version" "$VERSION"; then
      printf 'betterdiscordctl is already the latest version (%s).\n' "$VERSION" >&2
    else
      printf 'Local version (%s) is higher than GitHub version (%s).\n' "$VERSION" "$github_version" >&2
    fi
  fi
}

# Implementation functions

bdc_asar() {
  if [ "$global_asar" ]; then
    asar "$@"
  else
    if mkdir "$data/asar" 2>/dev/null; then
      pushd "$data/asar" >/dev/null
      printf '{"devDependencies":{"asar": "*"}}\n' > package.json
      printf 'Installing asar...\n' >&2
      npm install
    else
      pushd "$data/asar" >/dev/null
      printf 'Updating asar...\n' >&2
      npm update
    fi
    popd >/dev/null
    "$data/asar/node_modules/asar/bin/asar.js" "$@"
  fi
}

bd_patch() {
  verbose 1 'V: Unpacking core asar...' >&2
  bdc_asar e "$core/core.asar" "$core/core"

  if [ ! -d "$core/core" ]; then
    die 'ERROR: Failed to unpack core asar.' \
        'You may want to install or update nodejs and npm.'
  fi

  verbose 1 'V: Patching core entry...' >&2
  sed -e "s/core\.asar'/core'/g" -i "$core/index.js"
  sed \
    -e "/var *_url *=/ a var _betterDiscord = require('betterdiscord'); var _betterDiscord2;" \
    -e "/mainWindow *= *new/ a _betterDiscord2 = new _betterDiscord.BetterDiscord(mainWindow);" \
    -i "$core/core/app/mainScreen.js"
}

bd_unpatch() {
  verbose 1 'V: Removing core folder from modules...' >&2
  sed "s/core'/core.asar'/g" -i "$core/index.js"
  rm -rf "$core/core"
}

bd_map_entry_n() {
  sed 's/^.*\t\t.*\t\(.*\)$/\1/' "$@"
}

bd_map_fresh() {
  verbose 1 'V: Generating fresh bd_map number...' >&2
  bd_map_entry_n "$data/bd_map" | sort | awk 'BEGIN {max=-1} NF != 0 {if ($1>max+1) {exit}; max=$1} END {print max+1}'
}

bd_map_add() {
  entry="$(bd_map_get_repo "$2")"
  if [ "$entry" ]; then
    num=$(head -n1 <<< "$entry" | bd_map_entry_n)
  else
    num=$(bd_map_fresh)
  fi
  printf '%s\t\t%s\t%s\n' "$1" "$2" $num >> "$data/bd_map"
  printf '%s\n' $num
}

bd_map_get_dir() {
  grep -F "$1"$'\t\t' "$data/bd_map"
}

bd_map_get_repo() {
  grep -F $'\t\t'"$1"$'\t' "$data/bd_map"
}

bd_map_get_n() {
  grep $'\t'"$1\$" "$data/bd_map"
}

bd_map_remove() {
  grep -vF "$1"$'\t\t' "$data/bd_map" > "$data/bd_map.temp"
  mv "$data/bd_map.temp" "$data/bd_map"
}

# From https://github.com/cloudflare/semver_bash , licensed under BSD-2-Clause

function semverParseInto() {
  local RE='[^0-9]*\([0-9]*\)[.]\([0-9]*\)[.]\([0-9]*\)\([0-9A-Za-z-]*\)'
  eval $2=`echo $1 | sed -e "s#$RE#\1#"` # MAJOR
  eval $3=`echo $1 | sed -e "s#$RE#\2#"` # MINOR
  eval $4=`echo $1 | sed -e "s#$RE#\3#"` # PATCH
  eval $5=`echo $1 | sed -e "s#$RE#\4#"` # SPECIAL
}

function semverEQ() {
  local MAJOR_A=0
  local MINOR_A=0
  local PATCH_A=0
  local SPECIAL_A=0

  local MAJOR_B=0
  local MINOR_B=0
  local PATCH_B=0
  local SPECIAL_B=0

  semverParseInto $1 MAJOR_A MINOR_A PATCH_A SPECIAL_A
  semverParseInto $2 MAJOR_B MINOR_B PATCH_B SPECIAL_B

  if [ $MAJOR_A -ne $MAJOR_B ]; then return 1; fi
  if [ $MINOR_A -ne $MINOR_B ]; then return 1; fi
  if [ $PATCH_A -ne $PATCH_B ]; then return 1; fi
  if [[ "_$SPECIAL_A" != "_$SPECIAL_B" ]]; then return 1; fi
  return 0
}

function semverLT() {
  local MAJOR_A=0
  local MINOR_A=0
  local PATCH_A=0
  local SPECIAL_A=0

  local MAJOR_B=0
  local MINOR_B=0
  local PATCH_B=0
  local SPECIAL_B=0

  semverParseInto $1 MAJOR_A MINOR_A PATCH_A SPECIAL_A
  semverParseInto $2 MAJOR_B MINOR_B PATCH_B SPECIAL_B

  if [ $MAJOR_A -lt $MAJOR_B ]; then return 0; fi

  if [[ $MAJOR_A -le $MAJOR_B  && $MINOR_A -lt $MINOR_B ]]; then return 0; fi

  if [[ $MAJOR_A -le $MAJOR_B  && $MINOR_A -le $MINOR_B && $PATCH_A -lt $PATCH_B ]]; then return 0; fi

  if [[ "_$SPECIAL_A"  == "_" ]] && [[ "_$SPECIAL_B"  == "_" ]] ; then return 1; fi
  if [[ "_$SPECIAL_A"  == "_" ]] && [[ "_$SPECIAL_B"  != "_" ]] ; then return 1; fi
  if [[ "_$SPECIAL_A"  != "_" ]] && [[ "_$SPECIAL_B"  == "_" ]] ; then return 0; fi

  if [[ "_$SPECIAL_A" < "_$SPECIAL_B" ]]; then return 0; fi

  return 1
}

function semverGT() {
  semverEQ $1 $2
  local EQ=$?

  semverLT $1 $2
  local LT=$?

  if [ $EQ -ne 0 ] && [ $LT -ne 0 ]; then
    return 0
  else
    return 1
  fi
}

# Run command

case "$cmd" in
  status)
    bdc_status
    ;;
  install)
    bdc_install
    ;;
  update)
    bdc_update
    ;;
  uninstall)
    bdc_uninstall
    ;;
  upgrade)
    bdc_upgrade
    ;;
  *)
    die "ERROR: Unknown command: $cmd"
    ;;
esac
